---
title: "Index clinicaltrials.gov data"
author: "digital ECMT"
date: "19/11/2021"
output: html_document
---


```{r copyright notice}
 # 
 # This file is part of the cancer-trial-match distribution (https://github.com/digital-ECMT/cancer-trial-match).
 # Copyright (C) 2021 digital ECMT
 # 
 # This program is free software: you can redistribute it and/or modify  
 # it under the terms of the GNU General Public License as published by  
 # the Free Software Foundation, version 3 or later.
 #
 # This program is distributed in the hope that it will be useful, but 
 # WITHOUT ANY WARRANTY; without even the implied warranty of 
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License 
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 #


```




```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
##NOTE: the following packages are required to run this script, but should be installed (e.g. using code snippets below) before runnning the script, NOT as part of the script itself
# options(repos = "http://cran.us.r-project.org")
# install.packages("BiocManager")
# BiocManager::install("AnnotationDbi")
# BiocManager::install("org.Hs.eg.db")
# BiocManager::install("KEGGREST")
# BiocManager::install("KEGGlincs")
# BiocManager::install("hgu133a.db")
require(KEGGlincs)        ## GPL-3
require(KEGGgraph)        ## GPL >= 2
require(org.Hs.eg.db)     ## Artistic-2.0
require(KEGGREST)         ## Artistic 2.0
require(DBI)              ## LGPL-2.1 | LGPL-3 
require(RODBC)            ## GPL-2 | GPL-3
require(RPostgres)        ## GPL-3
require(RSQLite)          ## LGPL-2.1 | LGPL-3
require(jsonlite)         ## MIT
require(dplyr)            ## MIT
require(tidyr)            ## MIT
require(formattable)      ## MIT
require(kableExtra)       ## MIT
require(stringr)          ## MIT
require(splitstackshape)  ## GPL-3
require(reshape2)         ## MIT
require(tictoc)           ## Apache License (== 2.0
require(leaflet)          ## GPL-3
require(PostcodesioR)     ## GPL-3
require(igraph)           ## GPL-2 | GPL-3
require(tidygeocoder)     ## MIT
require(caret)
require(rpart)

## clean up first
rm(list=ls())

##get today's date
today <- format(Sys.Date(), format = "%d %B %Y")
```


**Date of data refresh: `r today`**  
  
  
```{r connect to SQLite DB} 
# Create an RSQLite database
con <- dbConnect(RSQLite::SQLite(), "indexedTrialData.sqlite")

dbListTables(con)

```
  
#### **Download and save a table of human genes and synonyms**  
  
```{r download and process a list of all human genes and their synonyms}

## start timer
tic("download a list of all human genes and their synonyms")


humanGenes <- read.table(file = "humanGenes.tsv", header = TRUE, quote = "", sep = "\t", fill = TRUE, stringsAsFactors = FALSE)

humanGenes <- dplyr::select(humanGenes, Symbol, Aliases)## drop everything except Symbol and Aliases columns


humanGenes$Aliases <- strsplit(x=humanGenes$Aliases, split = ",")## split the aliases on comma 
humanGenes <- unnest(data = humanGenes, cols = Aliases, keep_empty = TRUE) ## unnest to multiply rows, keep any rows with no aliases
humanGenes <- as.data.frame(humanGenes) ## convert to data frame

humanGenes$Aliases <- str_squish(string = humanGenes$Aliases) ## trim excess whitespace from Aliases values

## Symbol values are not represented among Aliases
# create a data frame with unique Symbol values
symbols <- data.frame("Symbol"=unique(humanGenes$Symbol), "Aliases"=unique(humanGenes$Symbol))
# bind this onto bottom of humanGenes data frame
humanGenes <- rbind(humanGenes,symbols)
# remove duplicated values, if any
humanGenes <- unique(humanGenes)
# sort on Symbol values
humanGenes <- humanGenes[order(humanGenes$Symbol), ] 

# drop any rows where Aliases is NA
humanGenes <- humanGenes[!is.na(humanGenes$Aliases), ]

## drop any rows where Aliases value is only a single character

## NOW humanGenes TABLE CONTAINS ALL HUMAN GENES AND THEIR SYNONYMS
## (61,593 unique symbols, 130,989 rows)

## stop timer
toc()

## delete symbols object to save memory
rm(symbols)
```

  
```{r save table of human genes to DB}
## preview
# formattable(head(humanGenes))

## create as a table in database
dbWriteTable(conn = con,name = "humanGenes", value = humanGenes, overwrite=TRUE)

## check it has saved
dbListTables(con)

```
    
#### **Download and save NCI thesaurus**  
  
```{r download and create NCIthesaurus table}

## specify URL for NCI thesaurus - this should always be the most recent? 
NCItURL <- "https://evs.nci.nih.gov/ftp1/NCI_Thesaurus/Thesaurus.FLAT.zip"

destFlatFilename <- "NCIt_FLAT.zip"
download.file(url=NCItURL,destfile = destFlatFilename)
unzip(zipfile = paste0(getwd(),"/",destFlatFilename))

NCIt <- read.table("Thesaurus.txt",header = FALSE, sep = "\t", comment.char = "", fill = TRUE, stringsAsFactors = FALSE, quote = "")
names(NCIt) <- c("ID","URL","ParentID","Synonyms","Description","PreferredTerm","Type","Class")

## an entity may have more than one class, so need to multiply rows
## split and unnest the Class column of NCIt
NCIt$Class <- strsplit(NCIt$Class, split = "\\|")
NCIt <- unnest(data = NCIt, Class)

## do the same for Parent column
## split ParentID column on pipe symbol
NCIt$ParentID <- strsplit(NCIt$ParentID, split = "\\|")
## unnest the ID column to multiply rows
NCIt <- unnest(data=NCIt,ParentID)

## drop unnecessary rows
NCIt <- unique(dplyr::select(NCIt, ID, ParentID, Synonyms, PreferredTerm, Class))

## join parent column back
## first, get the synonyms and IDs for parents
NCItParents <- NCIt[which(NCIt$ID %in% NCIt$ParentID), ]

## each parent term may have more than one synonym
## for simplicity, we will retain only the first synonym for each parent term
NCItParents$Synonyms <- gsub("\\|.*","",NCItParents$Synonyms)

NCItParents <- unique(dplyr::select(NCItParents, "ParentID"="ID", "Parent_synonym"="Synonyms"))

## merge parents on entity ID = parent ID
NCIt <- merge(x=NCIt,y=NCItParents,by.x="ParentID",by.y="ParentID",all.x=TRUE)

## split and unnest the Synonyms column
NCIt$Synonyms <- strsplit(NCIt$Synonyms, split = "\\|")
NCIt <- unnest(data = NCIt, Synonyms)

NCIt <- as.data.frame(NCIt)

## add a column to indicate date downloaded
NCIt$downloaded <- Sys.Date()

## drop redundant rows, if any
NCIt <- unique(NCIt)
```


```{r write NCIt to database}
## create as a table in database
dbWriteTable(conn = con,name = "NCIt", value = NCIt, overwrite=TRUE)

```
  
#### **Map NCIt drugs to targets via KEGG**  
  
```{r use KEGG BRITE}
## download Target-based Classification of Drugs (JSON format) from: https://www.genome.jp/kegg-bin/download_htext?htext=br08310&format=json&filedir=
## save as "kegg_brite.json"
# kegg_brite <- fromJSON("kegg_brite.json")

## CAN'T USE THIS, AS SOME OF THE TARGETS LISTED REFER TO GROUPS OF PROTEINS, NOT INDIVIDUAL PROTEINS.. 



```
  
#### **Map NCIt drugs to targets via NCIt relationships**   

```{r download NCIt in OWL format}
## we will download the inferred version of the thesaurus, described at https://evs.nci.nih.gov/evs-download/thesaurus-downloads 

# NCIt_url_OWL <- "https://evs.nci.nih.gov/ftp1/NCI_Thesaurus/ThesaurusInf_21.10d.OWL.zip"
# destOWLfilename <- "NCIt_OWL.zip"
# download.file(url=NCIt_url_OWL,destfile = destOWLfilename)
# unzip(zipfile = paste0(getwd(),"/",destOWLfilename))

## the unzipped file is called "ThesaurusInferred.owl"
```

```{r use R ontocat to navigate ontology}

## install.packages("BiocManager")
## BiocManager::install("ontoCAT")
## "not available for R 3.6.2" (deprecated and no longer supported?)

```
  
```{r load using OntologyX}
## download NCIt in OBO format from EMBL?
## see https://www.ebi.ac.uk/ols/ontologies/ncit
## download manually 
# require(ontologyIndex)
# ontology <- get_ontology("ncit_obo.owl")


```

```{r read NCIt in OWL format}
## issues creating miniconda environment due to apostrophe in name of Users folder
## Error 127 occurred creating conda environment C:/Users/O’ReganPaul/AppData/Local/r-miniconda/envs/r-reticulate

## import owlready2





```

```{r subset NCIt for Pharmacologic Substance}


NCIt_Pharmacologics <- unique(dplyr::filter(NCIt, Class=="Pharmacologic Substance"))

## delete NCIt and NCItParents objects to save memory
rm(NCIt)
rm(NCItParents)

```

```{r define function to map drug names to KEGG drug IDs}

# test using "1-methyl-D-tryptophan", aka "Indoximod"

getDrugID <- function(drugName){
  if(is.na(drugName)) return(NA)
  ## get drug ID
  drugid <- tryCatch({names(keggFind(database = "drug", query = drugName))},
             error=function(cond) {return(NA)})
  if(is.null(drugid)) return(NA)
  if(is.na(drugid)) return(NA)
  drugid <- as.list(drugid)
  return(drugid)
}

```

```{r map NCIt drug names to KEGG drug IDs}
## NOT RUN, AS TAKES >20 HOURS TO COMPLETE
## ONCE COMPLETE, NEED TO ALSO MAP FROM DRUG ID TO TARGET GENE ID, AND THEN FROM TARGET GENE ID TO TARGET GENE SYMBOL... 


# NCIt_Pharmacologics$kegg_drug_id <- NA
# 
# tic("index NCIt pharmacologics with kegg drug id")
# for(i in 1:length(unique(NCIt_Pharmacologics$ID))) {
#   print(paste0("i:", i))
#   id <- unique(NCIt_Pharmacologics$ID)[i]
#   print(paste0("ID:", id))
#   synonyms <- unique(NCIt_Pharmacologics$Synonyms[NCIt_Pharmacologics$ID == id])
#   print(paste(synonyms, collapse = ", "))
#   kegg_drugid <- NA
#   ## loop through synonyms and call KEGG API
#   for(j in 1:length(synonyms)) {
#     kegg_drugid <- getDrugID(synonyms[j])
#     if(!is.na(kegg_drugid)) break
#   }
#   print(paste0("kegg drug id:", kegg_drugid))
#   NCIt_Pharmacologics$kegg_drug_id[NCIt_Pharmacologics$ID == id] <- kegg_drugid
# }
# toc()


```
  
#### **Download lat, long values for UK postcodes**  
  
```{r download ordnance survey data}
## download from https://www.freemaptools.com/download/full-uk-postcodes/ukpostcodes.zip
## Copyright and Reproduction
## As per : https://www.ons.gov.uk/methodology/geography/licences

##You may re-use this information (not including logos or Northern Ireland data) free of charge in any format or medium, under the terms of the relevant data owners' licence. In addition, the following attribution statements must be acknowledged or displayed whenever the owners data is used:

## Contains Ordnance Survey data © Crown copyright and database right 2021

## Contains Royal Mail data © Royal Mail copyright and database right 2021

## Source: Office for National Statistics licensed under the Open Government Licence v.3.0

## specify URL for download 
postcodesURL <- "https://www.freemaptools.com/download/full-uk-postcodes/ukpostcodes.zip"

destPostcodesFilename <- "uk_postcodes.zip"
download.file(url=postcodesURL, destfile = destPostcodesFilename)
unzip(zipfile = paste0(getwd(),"/",destPostcodesFilename))

uk_postcodes <- read.csv("ukpostcodes.csv", header = TRUE, stringsAsFactors = FALSE)


## create as a table in database
dbWriteTable(conn = con,name = "uk_postcodes", value = uk_postcodes, overwrite=TRUE)

```

#### **Define controlled terms and synonyms for cancer types**  
  
```{r create table of cancer types}
## conditionSynonyms specifies which cancer types are of interest, and which condition names (as used by clinicaltrials.gov) will be considered as matches for each

## synonyms define on basis of those in clinicaltrials.gov
conditionSynonyms <- read.csv(file = "conditionSynonyms5.csv", stringsAsFactors = FALSE)

## trim leading/trailing whitespace, if any
conditionSynonyms$condition.synonyms <- str_squish(string = conditionSynonyms$condition.synonyms)

## remove redundancy, if any
conditionSynonyms <- unique(conditionSynonyms)

## create as a table in database
dbWriteTable(conn = con,name = "conditionSynonyms", value = conditionSynonyms, overwrite=TRUE)

## check it has saved
dbListTables(con)

```
  
#### **Connect to clinicaltrials.gov**  
  
```{r connect to clinicaltrialsgov}  
## specify user name and password for AACT account
## see https://aact.ctti-clinicaltrials.org/ for how to create an account

## load configuration data from JSON file
## configuration <- rjson::fromJSON(file = "trialMatchConfiguration.json")

## jsonlite is MIT
configuration <- jsonlite::fromJSON(txt = "trialMatchConfiguration.json")
aact.username <- configuration$aact.username
aact.password <- configuration$aact.password


## connect via RPostgres (GPL-3 licence)
drv = RPostgres::Postgres()
conn2 <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )
```
 
#### **Get study info for all interventional cancer studies (globally, ever)**  
  
```{r get study data}

## get data for all cancer studies that have reported results
cancerStudiesQ <- "SELECT s.nct_id, s.brief_title, s.phase, s.acronym, s.number_of_arms, s.number_of_groups,  s.overall_status, s.last_update_posted_date, c.name AS condition
FROM studies s
INNER JOIN conditions c ON c.nct_id = s.nct_id
inner join calculated_values cv on cv.nct_id = s.nct_id
WHERE s.study_type LIKE ('Interventional')
and (c.downcase_name like '%cancer%'
or c.downcase_name like '%neoplasm%'
or c.downcase_name like '%carcinoma%'
or c.downcase_name like '%tumo%')"



## get data from clinicaltrials.gov
cancerStudies <- dbGetQuery(conn2,cancerStudiesQ)

## add a column to indicate refresh date
cancerStudies$Refresh.date <- today

```
   

#### **Map verbatim condition names to controlled set of cancer types**  
  
```{r tokenise and join to condition synonyms}
## we can't just join to condition synonyms as condition may include extra words
## such as "Stage IV Lung Cancer AJCC v8" and "Metastatic Lung Non-Small Cell Carcinoma"

## we will provide condition synonyms as custom tokens, then tokenise, unnest and perform the join
custom_tokens <- unique(conditionSynonyms$condition.synonyms)

## tokenise the condition names
cancerStudies$word <- as.list(corpus::text_tokens(x=cancerStudies$condition,                                                filter= corpus::text_filter(combine = custom_tokens, map_case=TRUE, connector="_", drop_punct=TRUE )))


## unnest
cancerStudies <- as.data.frame(unnest(data = cancerStudies, word)) 
## this function does insist on replacing whitespace with a character (here, underscore), so need to swap that back to whitespace
cancerStudies$word <- gsub(pattern = "_", replacement = " ", x=cancerStudies$word)


## join on word = conditionSynonyms$condition.synonyms
cancerStudies <- unique(merge(x=cancerStudies, by.x = "word", y=conditionSynonyms, by.y="condition.synonyms"))

## NOTE: ANY STUDY-CONDITION COMBINATIONS NOT REPRESENTED IN THE CONTROLLED TERMS WILL BE LOST AT THIS STAGE

## drop the word column
cancerStudies <- unique(dplyr::select(cancerStudies, -c(word)))


```
  

#### **Get study interventions**  
  
```{r get study interventions}
## format study IDs for SQL query
studyIDsForSQL <- paste0("\'",paste(unique(cancerStudies$nct_id), collapse = "\',\'"), "\'")

getInterventionsQ <- paste0("select i.nct_id, i.id AS intervention_id, i.name AS intervention_name 
from interventions i
where i.nct_id in (",
"", studyIDsForSQL,
")")

## get interventions from clinicaltrials.gov
interventions <- dbGetQuery(conn2,getInterventionsQ)

```

```{r process intervention names}
## duplicate intervention name
interventions$intervention_name_processed <- interventions$intervention_name
## convert to lowercase 
interventions$intervention_name_processed <- tolower(interventions$intervention_name_processed)

## split on words related to combinations of therapy
combinations_pattern = "\\bwith\\b|\\band\\b|\\/|\\+|\\bplus\\b|\\,"
interventions$intervention_name_processed <- strsplit(interventions$intervention_name_processed, split = combinations_pattern)
interventions <- as.data.frame(unnest(data = interventions, intervention_name_processed))

## split on brackets (e.g. values like "roniciclib (bay1000394)" and "e39 peptide (100mcg)")
brackets_pattern <- "\\(|\\)"
interventions$intervention_name_processed <- strsplit(interventions$intervention_name_processed, split = brackets_pattern)
interventions <- as.data.frame(unnest(data = interventions, intervention_name_processed))

## split on any substrings related to dose
## matches any digit, optionally followed by space, followed by "mg"
dose_pattern <- "[0-9]+ ?mg"
interventions$intervention_name_processed <- strsplit(interventions$intervention_name_processed, split = dose_pattern)
interventions <- as.data.frame(unnest(data = interventions, intervention_name_processed))

## trim excess whitespace
interventions$intervention_name_processed <- str_squish(interventions$intervention_name_processed)

```
  
#### **Join study interventions to NCIt pharmacologics**  
  
```{r join interventions to NCIt pharmacologics}
## create a temporary copy of NCIt pharmacologics
NCIt_Pharmacologics_temp <- unique(dplyr::select(NCIt_Pharmacologics, "NCIt_ID"="ID", Synonyms, PreferredTerm, "Mechanism"="Parent_synonym"))
## convert synonyms to lower case for joining
NCIt_Pharmacologics_temp$Synonyms <- tolower(NCIt_Pharmacologics_temp$Synonyms)

NCIt_Pharmacologics_temp <- unique(dplyr::select(NCIt_Pharmacologics, "NCIt_ID"="ID", Synonyms, PreferredTerm, "Mechanism"="Parent_synonym"))

interventions <- merge(x=interventions, by.x = "intervention_name_processed", all.x=TRUE, 
                       y=NCIt_Pharmacologics_temp, by.y = "Synonyms")

## delete temporary copy
rm(NCIt_Pharmacologics_temp)

## select and reorder columns
## remove duplicates
interventions <- unique(dplyr::select(interventions, nct_id, intervention_id, intervention_name, NCIt_ID, PreferredTerm, Mechanism))


```


#### **Drop studies with unmapped interventions from cancerStudies table**  
  
```{r omit cancerstudies with unmapped interventions}
cancerStudies <- unique(dplyr::filter(cancerStudies, nct_id %in% interventions$nct_id))



```

  
#### **write indexed cancer studies to database**  
  
```{r write cancerStudies to database}
## create as a table in database
dbWriteTable(conn = con,name = "cancerStudies", value = cancerStudies, overwrite=TRUE)

## check it has saved
dbListTables(con)


```


#### **Write indexed interventions to database**  
  
```{r write interventions to database}
## create as a table in database
dbWriteTable(conn = con,name = "interventions", value = interventions, overwrite=TRUE)

## check it has saved
dbListTables(con)

```

#### **Map UK cancer study sites to postcodes**  
  
```{r download facilities}

UKfacilitiesQ <- paste0("select f.nct_id, f.status, f.name AS facility_name, f.city, f.zip 
from facilities f
where f.nct_id in (",
"", studyIDsForSQL,
") AND lower(f.country) = 'united kingdom'")

## get criteria from clinicaltrials.gov
uk_facilities <- dbGetQuery(conn2,UKfacilitiesQ)



```

```{r map postcodes to lat and long}
## convert postcodes to lowercase for join
uk_postcodes$postcode_lower <- tolower(uk_postcodes$postcode)
uk_facilities$zip_lower <- tolower(uk_facilities$zip)

## merge
uk_facilities <- merge(x=uk_facilities, by.x = "zip_lower", all.x = TRUE, y=uk_postcodes, by.y="postcode_lower")

## select and reorder columns
uk_facilities <- unique(dplyr::select(uk_facilities, nct_id, facility_name, status, city, latitude, longitude))

## delete uk_postcodes object from memory
rm(uk_postcodes)
```

```{r map cities to lat and long}

## get a list of cities that are still missing lat, long values 
missing_cities <- data.frame(verbatim = as.character(unique(uk_facilities$city[is.na(uk_facilities$latitude)])))

## need to process 
missing_cities$processed <- as.character(missing_cities$verbatim)
missing_cities$processed <- strsplit(x=missing_cities$processed, split = ",")
missing_cities <- as.data.frame(unnest(data = missing_cities, processed))
missing_cities$processed <- str_squish(missing_cities$processed)
missing_cities$processed <- paste0(missing_cities$processed, ", ", configuration$country)


## use tidygeocoder (MIT licence)
## need append country from config file after city name...
geocoder_addresses <- as.data.frame(tidygeocoder::geo(address = unique(missing_cities$processed), method = 'osm'))

## join to missing cities
missing_cities <- merge(x=missing_cities, by.x="processed", y=geocoder_addresses, by.y="address")

## join to uk_facilities
uk_facilities <- merge(x=uk_facilities, by.x="city", all.x=TRUE, y=dplyr::select(missing_cities, verbatim, "geo_lat"="lat", "geo_long"="long"), by.y = "verbatim")


## replace the missing latitude and longitude values with the geocoder values
uk_facilities$latitude[is.na(uk_facilities$latitude)] <- uk_facilities$geo_lat[is.na(uk_facilities$latitude)]

uk_facilities$longitude[is.na(uk_facilities$longitude)] <- uk_facilities$geo_long[is.na(uk_facilities$longitude)]

## select and reorder columns
uk_facilities <- unique(dplyr::select(uk_facilities, nct_id, facility_name, status, city, latitude, longitude))
```

```{r write uk facilities to database}
## create as a table in database
dbWriteTable(conn = con,name = "uk_facilities", value = uk_facilities, overwrite=TRUE)

## check it has saved
dbListTables(con)

```

#### **Get eligibility criteria**  
  
```{r get eligibility criteria from ct}
getEligibilities <- paste0("select * 
from eligibilities 
where nct_id in (",
"", studyIDsForSQL,
")")

## get criteria from clinicaltrials.gov
eligibilities <- dbGetQuery(conn2,getEligibilities)

```

```{r split into individual eligibility criteria}

## split into individual criteria on single line breaks
eligibilities$criteria <- strsplit(eligibilities$criteria, split = "\n")
## unnest so each criterion gets its own row
eligibilities <- as.data.frame(unnest(data = eligibilities, cols = criteria))
## drop any empty elements
eligibilities <- eligibilities[eligibilities$criteria != "", ] ## drop empty elements

```

```{r classify as inclusion exclusion criteria}

## add a column to indicate criterion type
eligibilities$criterion.type <- NA

## set first value as "INCLUSION"
eligibilities$criterion.type[1] <- "INCLUSION"

## tag first criterion that equals "exclusion criteria:" (case-insensitive, with or without colon)
eligibilities$criterion.type[grep(pattern = "exclusion criteria:?$", x=eligibilities$criteria, ignore.case = TRUE)] <- "EXCLUSION"

## fill "down" using the tdiyr::fill() function
eligibilities <- tidyr::fill(data=eligibilities, criterion.type, .direction="down")

```

```{r impute missing values for gender}
## for gender, replace "All" with "Male|Female"
eligibilities$gender[eligibilities$gender=="All"] <- "Male|Female"
## do the same for missing values
eligibilities$gender[is.na(eligibilities$gender)] <- "Male|Female"

```

```{r impute missing values for minimum age}

## for minimum ages are all either "xxx months", "1 year", "xxx years" or "N/A"
## convert all values to years...
min_age_month_indices <- grep(pattern = "month", x=eligibilities$minimum_age, ignore.case = TRUE)
## trim off first space and everything after
eligibilities$minimum_age[min_age_month_indices] <- gsub(pattern = " .*", replacement = "", x=eligibilities$minimum_age[min_age_month_indices])
## convert to numeric
# eligibilities$minimum_age[min_age_month_indices] <- as.numeric(eligibilities$minimum_age[min_age_month_indices])
## divide by 12 to get min age in years
eligibilities$minimum_age[min_age_month_indices] <- round(as.numeric(eligibilities$minimum_age[min_age_month_indices])/12, digits = 1)

## just trim off " years" from min ages in years
min_age_year_indices <- grep(pattern = "year", x=eligibilities$minimum_age, ignore.case = TRUE)
eligibilities$minimum_age[min_age_year_indices] <- gsub(pattern = " .*", replacement = "", x=eligibilities$minimum_age[min_age_year_indices])

## impute missing values with zero
eligibilities$minimum_age[is.na(eligibilities$minimum_age)] <- 0
eligibilities$minimum_age[eligibilities$minimum_age == "N/A"] <- 0

## convert to numeric
eligibilities$minimum_age <- as.numeric(eligibilities$minimum_age)

```

```{r impute missing values for maximum age}


## for maximum age, all values are in years, or NA or "N/A"
# to test... 
## unique(grep(pattern = "year", x=eligibilities$maximum_age, ignore.case = TRUE, value = TRUE, invert = TRUE))

## trim off first space and everything after
eligibilities$maximum_age <- gsub(pattern = " .*", replacement = "", x=eligibilities$maximum_age)

## impute missing values with 120
eligibilities$maximum_age[is.na(eligibilities$maximum_age)] <- 120
eligibilities$maximum_age[eligibilities$maximum_age == "N/A"] <- 120

## convert to numeric
eligibilities$maximum_age <- as.numeric(eligibilities$maximum_age)

```

```{r write eligibilities to database}
## create as a table in database
dbWriteTable(conn = con,name = "eligibilities", value = eligibilities, overwrite=TRUE)

## check it has saved
dbListTables(con)

```

#### **Get design groups (study arms)**  
  
  
```{r get design groups from ct}
getDesignGroupsQ <- paste0("select dg.nct_id, dg.id as dg_id, dg.title as dg_title, dg.description as dg_description, dg.group_type as dg_group_type, dgi.intervention_id
from design_groups dg
left join design_group_interventions dgi on dg.id = dgi.design_group_id 
where dg.nct_id in (",
"", studyIDsForSQL,
")")

## get criteria from clinicaltrials.gov
design_groups <- dbGetQuery(conn2,getDesignGroupsQ)

## NOTE, SOME STUDIES HAVE NO DESIGN GROUPS SPECIFIED, BUT MAY HAVE RESULT GROUPS SPECIFIED

```
  
#### **Get result groups**  
  
```{r get result groups}
getResultGroupsQ <- paste0("select rg.nct_id, rg.id as rg_id, ctgov_group_code, result_type, rg.title as rg_title, rg.description as rg_description
from result_groups rg 
where rg.nct_id in (",
"", studyIDsForSQL,
")")

## get criteria from clinicaltrials.gov
result_groups <- dbGetQuery(conn2,getResultGroupsQ)

```

#### **Join interventions to result groups**  
  
Interventions are explicitly associated with design groups in the ct.gov schema, but not with result groups. Therefore, we will associate interventions with result groups as follows:  
  
* Where a study has only a single arm (*studies$number_of_arms*), we will assume all study interventions were administered in all result groups.  
* If a result group title exactly matches a design group title, we will associate interventions based on the design group interventions.  
* For remaining studies, we will predict which design group each result group belongs to based on comparison of the titles and descriptions for design and result groups.  
  
Before creating any predictive model, we will first need to ensure that preferred terms for interventions are used in descriptions for both design groups and result groups.  
For example, study NCT00721409 uses only **"PD 0332991"** as intervention name in design groups, and only either "Arm A" or "Arm B" for design groups titles, but uses e.g. "**Palbociclib** + Letrozole" as result group titles. 
  
We will get the preferred names (where available) for drugs from the NCI Thesaurus.    

```{r create empty table that will hold predicted mappings}

result_group_interventions <- data.frame(nct_id = character(0), 
                                         rg_id = character(0), 
                                         intervention_id = character(0))

## create a vector that will hold list of unmapped result groups
## The elements of setdiff(x,y) are those elements in x but not in y
unmapped_result_group_ids <- setdiff(x=result_groups$rg_id, y=result_group_interventions$rg_id)
length(unmapped_result_group_ids)
unmapped_result_groups <- unique(dplyr::filter(result_groups, rg_id %in% unmapped_result_group_ids))


## NOTE SOME RESULT GROUPS ARE "TOTAL" i.e. total values for all groups
## these will not be specified as design groups
## if we try to map these onto a design group, the mapping is likely to barf
## MAY BE BEST TO EXCLUDE THESE GROUPS AT THIS POINT - e.g. by filtering result groups and retaining only those where result_type = "Outcome" or "Reported Event"... 
```



```{r concatenate titles and descriptions for unmapped result groups}


unmapped_result_groups$rg_title_description <- paste(unmapped_result_groups$rg_title, unmapped_result_groups$rg_description, sep = ": ")

## replace mu (micro) symbols with u as this causes mapping function to barf
unmapped_result_groups$rg_title_description <- gsub(pattern = "\U00B5", replacement = "u", x=unmapped_result_groups$rg_title_description)

```






#### **Assign interventions for single arm studies**  
  
```{r get single arm studies}
single_arm_study_IDs <- unique(cancerStudies$nct_id[cancerStudies$number_of_arms==1])

single_arm_result_groups <- unique(dplyr::filter(result_groups, nct_id %in% single_arm_study_IDs))
single_arm_result_groups <- unique(dplyr::select(single_arm_result_groups, nct_id, rg_id))
## join to interventions on nct_id alone, means all interventions will be mapped to all result groups for those studies
single_arm_result_groups <- unique(merge(x = single_arm_result_groups, by.x = "nct_id", y=dplyr::select(interventions, nct_id, intervention_id), by.y = "nct_id"))
  

## row bind onto empty result group interventions table
result_group_interventions <- rbind(result_group_interventions, single_arm_result_groups)


## update vector of unmapped result groups
## The elements of setdiff(x,y) are those elements in x but not in y
unmapped_result_group_ids <- setdiff(x=result_groups$rg_id, y=result_group_interventions$rg_id)
length(unmapped_result_group_ids)
unmapped_result_groups <- unique(dplyr::filter(result_groups, rg_id %in% unmapped_result_group_ids))


```

  
#### **Assign interventions based on match between group titles**  
  
```{r match design and result group titles}

mapped_result_groups <- merge(x=unique(dplyr::select(unmapped_result_groups, nct_id, rg_id, rg_title)), by.x = c("nct_id", "rg_title"), all.x = FALSE, y= unique(dplyr::select(design_groups, nct_id, dg_title, intervention_id)), by.y = c("nct_id", "dg_title"), all.y = FALSE)

## drop the title
mapped_result_groups <- unique(dplyr::select(mapped_result_groups, nct_id, rg_id, intervention_id))


## row bind onto result group interventions table
result_group_interventions <- unique(rbind(result_group_interventions, mapped_result_groups))


## update vector of unmapped result groups
## The elements of setdiff(x,y) are those elements in x but not in y
unmapped_result_group_ids <- setdiff(x=result_groups$rg_id, y=result_group_interventions$rg_id)
length(unmapped_result_group_ids)
```


#### **Assign interventions based on similarity between design, result group descriptions**   
```{r get design groups for unmapped result groups}
unmapped_design_groups <- unique(dplyr::filter(design_groups, nct_id %in% unmapped_result_groups$nct_id))

unmapped_design_groups$dg_title_description <- paste(unmapped_design_groups$dg_title, unmapped_design_groups$dg_description, sep = ": ")
## replace mu (micro) symbols with u as this causes mapping function to barf
unmapped_design_groups$dg_title_description <- gsub(pattern = "\U00B5", replacement = "u", x=unmapped_design_groups$dg_title_description)



```



  
```{r exclude studies that are not in unmapped design groups}
## some studies (e.g. NCT00058539) do not specify number of arms, nor do they have any design groups to map to (likely single-arm studies)

## for now, we will exclude these from unmapped_result_groups
unmapped_result_groups <- unique(dplyr::filter(unmapped_result_groups, nct_id %in% unmapped_design_groups$nct_id))

```
  
```{r define stopwords}
stopwords <- as.data.frame(tidytext::get_stopwords())


```

    

```{r define function to create document term matrix}

## define a function that will... 
# accept custom tokens to be included in tokenisation
# tokenise each (may include drug names as custom tokens)
# create document-term matrix

create_dtm <- function(dataframe, text_column, id_column, custom_tokens) {
  ## 1. TOKENISE THE TEXT COLUMN
  ## need to tokenise using corpus function, as this allows drug synonyms, inc multi word synonyms, to be specified upfront as tokens so they don't get split
  dataframe$word <- as.list(corpus::text_tokens(x=dataframe[ , which(names(dataframe)==text_column)],                                                filter= corpus::text_filter(combine = custom_tokens, map_case=FALSE, connector="_", drop_punct=TRUE )))
  ## unnest
  dataframe <- as.data.frame(unnest(data = dataframe, word)) 
  ## this function does insist on replacing whitespace with a character (here, underscore), so need to swap that back to whitespace
  dataframe$word <- gsub(pattern = "_", replacement = " ", x=dataframe$word)
  ## remove stopwords
  dataframe <- anti_join(x=dataframe, y=stopwords)
  
  ## 2. CREATE DOCUMENT-TERM MATRIX
  ## count each word in each description
  dataframe <- dataframe %>% 
    group_by_at(id_column) %>%
    count(word, sort=FALSE) %>%
    ungroup() %>%
    as.data.frame()
  ## use reshape2::dcast so get a dataframe as a result
  dataframe <- reshape2::dcast(data=dataframe, formula = as.formula(paste(id_column, "~ word")), value.var = "n")
  ## convert NA to zero
  dataframe <- dataframe %>% mutate_all(~replace(., is.na(.), 0))
  ## convert id to factor
  dataframe[ , which(names(dataframe)==id_column)] <- as.factor(dataframe[ , which(names(dataframe)==id_column)])
  
  ## 3. RETURN DOCUMENT-TERM MATRIX
  return(dataframe)
}

```
    
  
  
  
```{r loop through unmapped result groups and predict design group}

for(i in 1: length(unique(unmapped_result_groups$nct_id))) {
  study_id <- unique(unmapped_result_groups$nct_id)[i]
  print(study_id)
  temp_unmapped_dgs <- unique(dplyr::filter(unmapped_design_groups, nct_id == study_id))
  print(nrow(temp_unmapped_dgs))
  temp_unmapped_rgs <- unique(dplyr::filter(unmapped_result_groups, nct_id == study_id))
  print(nrow(temp_unmapped_rgs))
  study_interventions <- unique(interventions$intervention_name[interventions$nct_id==study_id])
  print(study_interventions)
  
  ## create document-term matrix for design group descriptions
  unmapped_dgs_dtm <- create_dtm(dataframe = temp_unmapped_dgs, text_column = "dg_title_description", id_column = "dg_id", custom_tokens = study_interventions)
  
  ## create DTM for result group descriptions
  unmapped_rgs_dtm <- create_dtm(dataframe = temp_unmapped_rgs, text_column = "rg_title_description", id_column = "rg_id", custom_tokens = study_interventions)
  
  
  
  ## make names valid, otherwise rpart will barf...
  names(unmapped_dgs_dtm) <- gsub(" ", "_", names(unmapped_dgs_dtm))
  names(unmapped_rgs_dtm) <- gsub(" ", "_", names(unmapped_rgs_dtm))
  ## need to create model using terms that are common to both DTMs, otherwise can end up trying to predict on variables we don't have... 
  common_terms <- intersect(names(unmapped_dgs_dtm), names(unmapped_rgs_dtm))
  ## drop non-overlapping columns from DGs_dtm
  unmapped_dgs_dtm <- dplyr::select(unmapped_dgs_dtm, dg_id, all_of(common_terms))
  print(common_terms)
  
  tryCatch({
            ## create decision tree model
            modFit <- rpart::rpart(formula = dg_id ~., method = "class", data = unmapped_dgs_dtm, control =rpart.control(minsplit = 1,minbucket=1, cp=0))
            ## (optional) print tree
            rpart.plot(modFit)
            ## predict design group for each result group
            study_predictions <- data.frame(nct_id = as.character(study_id),
                          rg_id = as.character(unmapped_rgs_dtm$rg_id), 
                          predicted_design_group = as.character(predict(object = modFit, unmapped_rgs_dtm, type = "class"))
                          )
            
            }, error=function(cond) {
              return(study_predictions <- data.frame(nct_id = study_id,
                                                     result_group_id = unmapped_rgs_dtm$rg_id,
                                                     predicted_design_group = NA
                          ))})
  ## now we have predicted design group for each unmapped result group for this study
  ## what we want is study id, rg_id, predicted intervention id
  ## so we need to get intervention ids for each predicted design group
  study_predictions$predicted_design_group <- as.character(study_predictions$predicted_design_group)
  study_predictions <- merge(x=study_predictions, by.x=c("nct_id", "predicted_design_group"), all.x=TRUE, y=unique(dplyr::select(design_groups, nct_id, dg_id, intervention_id)), by.y=c("nct_id", "dg_id"))
  
  ## make names match those for result_group_interventions
  study_predictions <- unique(dplyr::select(study_predictions, names(result_group_interventions)))
  ## rowbind onto result_group_interventions
  result_group_interventions <- unique(rbind(result_group_interventions, study_predictions))
  
}


## update vector of unmapped result groups
## The elements of setdiff(x,y) are those elements in x but not in y
unmapped_result_group_ids <- setdiff(x=result_groups$rg_id, y=result_group_interventions$rg_id)
length(unmapped_result_group_ids)




### NEED TO MAKE THIS WORK WITH STUDY NCT00014222
## BARFS WIT ERROR: 
# Error: Obsolete data mask.
# x Too late to resolve `5µg` after the end of `dplyr::mutate()`.
# i Did you save an object that uses `5µg` lazily in a column in the `dplyr::mutate()` expression ?

## BARFS AT CREATION OF DESIGN GROUP DTM (due presence of microgram symbol?)
## try replacing mu symbols with u?
## use gsub e.g. 
# gsub(pattern = "\U00B5", replacement = "u", x=" Filgrastim 5µg/kg/d ")
```


```{r assign interventions for single arm studies}
# for(i in 1:length(unique(rgs$nct_id))) {
#   nct_id <- unique(rgs$nct_id)[i]
#   print(nct_id)
#   number_arms <- unique(rgs$number_of_arms[rgs$nct_id==nct_id])
#   print(number_arms)
#   study_interventions <- unique(interventions$intervention_name[interventions$nct_id == nct_id])
#   print(study_interventions)
#   study_intervention_ids <- unique(interventions$intervention_id[interventions$nct_id == nct_id])
#   print(study_intervention_ids)
#   if(!is.na(number_arms) & number_arms==1) {
#     rgs$rg_interventions[rgs$nct_id==nct_id] <- list(study_interventions)
#     rgs$rg_intervention_ids[rgs$nct_id==nct_id] <- list(study_intervention_ids)
#   }
# }

## if result group titles match design group titles, match on that basis

  ## finally, if still no match, predict match based on document term matrices of titles and descriptions
```

#### **Assign interventions based on match between group titles**  
  
```{r get interventions for each design group}
# design_group_interventions <- unique(dplyr::select(design_groups, nct_id, dg_id, dg_title, dg_description, "dg_intervention_id"="intervention_id"))
# 
# design_group_interventions$dg_title_description <- paste(design_group_interventions$dg_title, design_group_interventions$dg_description, sep = ": ")
# 
# testrun <- merge(x=design_group_interventions, by.x=c("nct_id", "dg_title"), all.x=FALSE,y=rgs, by.y = c("nct_id", "rg_title"), all.y=TRUE)


```









  


#### **Define function to replace drug names with preferred terms (where available)**  
  
The function will accept a synonym, then:  
* convert it to lower case  
* get the preferred term(s) from NCIt_drugs_preferred table  
* convert preferred term to lower case  
* return the preferred term  



```{r define function to replace drug synonyms with preferred terms}

## define a function that will be called if str_replace_all() finds a match between a string (lowercase description) and a pattern (lowercase synonyms)...
synonym2preferred <- function(synonym) {
  synonym <- tolower(synonym)
  preferred <- NCIt_Pharmacologics$PreferredTerm[NCIt_Pharmacologics$Synonyms_lower==synonym] ## get the preferred term for that synonym
  preferred <- paste(unique(preferred), collapse = ", ") ## in case more than one match
  preferred <- tolower(preferred)
  return(preferred) ## return the preferred term
}

```
  
We will use the stringr::str_replace_all() function to:  
* look for a synonym that appears in NCI thesaurus (based on a pattern of all synonyms collapsed, pipe-separated)  
* when found, call the function defined above to replace it with the preferred term  
  
```{r replace synonyms in result group title descriptions}
# for(i in 1:length(unique(rgs$nct_id))) {
#   nct_id <- unique(rgs$nct_id)[i]
#   study_intervention_NCIt_IDs <- c(unique(interventions$NCIt_ID[interventions$nct_id == nct_id]))
#   print(study_intervention_ids)
#   study_intervention_synonyms <- unique(NCIt_Pharmacologics$Synonyms[NCIt_Pharmacologics$ID %in% study_intervention_NCIt_IDs])
#   if(length(study_intervention_synonyms)==0) next
#   study_intervention_synonyms <- str_c("\\b", study_intervention_synonyms, "\\b", collapse="|")
#   ## collapse the synonyms to create a pattern used to identify
#   
#   print(study_intervention_synonyms)
# }



```

  
  
  
```{r define the pattern used to identify valid synonyms}

## define a pattern that CONTAINS ONLY SYNONYMS FOR THE INTERVENTIONS USED IN THESE STUDIES
## (OTHERWISE R WILL ABORT...)
## omit rows that aren't listed as an intervention in a design group
# NCIt_drugs_preferred <- dplyr::filter(NCIt_drugs_preferred, Synonyms %in% design_group_interventions$intervention_name)


## we will use a pattern that is all the relevant synonyms, collapsed into a single string separated by pipe symbols...
# synonyms_lower_collapsed <- str_c("\\b", unique(NCIt_drugs_preferred$Synonyms_lower), "\\b", collapse="|")

```

  










  








#### **Define function to predict mapping from result group to design group**  
  
  
  













```{r disconnect from  database}

# disconnect from clincialtrials.gov
dbDisconnect(conn2)

# Disconnect from SQLite database
dbDisconnect(con)


```
  

    

`r knitr::knit_exit()`    



```{r get design group interventions from clinicaltrials.gov}

getDesignGroupInterventions <- paste0("select dg.nct_id, dg.id as dg_id, dg.group_type, dg.title as dg_title, dg.description as dg_description, i.name as intervention_name 
from design_groups dg
inner join design_group_interventions dgi on dgi.design_group_id = dg.id
inner join interventions i on i.id = dgi.intervention_id
where dg.nct_id in (",
"", studyIDsForSQL,
")")
# 
## get criteria from clinicaltrials.gov
design_group_interventions <- dbGetQuery(conn2, getDesignGroupInterventions)

design_group_interventions_aggregated <- design_group_interventions %>%
    group_by(nct_id, dg_id) %>%
    summarise_all(function(x) {paste(unique(x), collapse = "; ")}) %>%
    as.data.frame()


kbl(design_group_interventions_aggregated, format = "html",escape = FALSE) %>%
  kable_styling(fixed_thead = T, bootstrap_options = c("striped", "hover", "condensed")) %>%
  scroll_box(width = "100%", height = "200px")
```  
   


  
#### **Get cancer studies with results**  
  

#### **Map interventions to molecular targets**  
  

```{r get molecular targets for cancerStudies interventions}
## first, get all interventions (note that there will be some redundancy due to case)
drugs.targets <- unique(dplyr::select(cancerStudiesResults,nct_id,interventions))

## keep interventions column as verbatim so can join later
## make a duplicate column
drugs.targets$interventions.processed <- drugs.targets$interventions


## split and unnest on " + "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\+ ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unneston the word " plus "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " plus ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unneston the word " and "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " and ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " & "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\& ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " or "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " or ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " (+) "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\(\\+\\) ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " with "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " with ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

## also split on brackets
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\(")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)
# remove closing bracket
drugs.targets$interventions.processed <- gsub(pattern = "\\)", replacement = "", x=drugs.targets$interventions.processed)


## trim off anything related to dose
# pattern is (a number, with or without a decimal point) with/without a space, followed by "mg", anything after "mg is removed
drugs.targets$interventions.processed <- gsub(pattern = " \\d+\\.?\\d+ ?mg.*", replacement = "", x=drugs.targets$interventions.processed, ignore.case = T)

## convert to lowercase
drugs.targets$interventions.processed <- tolower(drugs.targets$interventions.processed)

drugs.targets <- as.data.frame(drugs.targets)



## join to NCIthesaurus 
## drop rows without a match 
drugs.targets <- merge(x=drugs.targets, 
      by.x = "interventions.processed", 
      all.x = FALSE,
      y= unique(dplyr::select(NCIthesaurus, "NCI_ID"="ID", SynonymsLower, PreferredTerm, ParentTerm)), 
      by.y = "SynonymsLower")



# convert empty cells to NA
drugs.targets$PreferredTerm[drugs.targets$PreferredTerm==""] <- NA

## drop the interventions processed column
drugs.targets <- unique(dplyr::select(drugs.targets, -c(interventions.processed)))

## drop any rows that don't have a preferred term
#drugs.targets <- unique(drugs.targets[!is.na(drugs.targets$PreferredTerm), ])


## reduce number of rows
drugs.targets <-unique(dplyr::select(drugs.targets, interventions, PreferredTerm,NCI_ID))

## map preferred terms to drug IDs in KEGG
# drugs.targets.preferred <- unique(dplyr::select(drugs.targets, PreferredTerm))
```


```{r get drug ids based on intervention name}
## add an empty column to hold drug ID
drugs.targets$drugID <- NA

tic("get drug IDs based on intervention name")
for(i in 1:nrow(drugs.targets)) {
  print(i)
  drugName <- drugs.targets$interventions[i]
  preferred <- drugs.targets$PreferredTerm[i]
  print(drugName)
  drugID <- getDrugID(drugName)
  if(is.na(drugID)) {
    drugID <- getDrugID(preferred)
  }
  
  drugs.targets$drugID[i] <- drugID
  print(drugs.targets$drugID[i])
}  
toc()

## unnest
drugs.targets <- as.data.frame(unnest(data = drugs.targets, drugID, keep_empty = TRUE))


```

```{r define function to get drug target IDs from KEGG}

getDrugTargetID <- function(drugID){
  if(is.na(drugID)) return(NA)
  geneid <- tryCatch({keggGet(drugID)[[1]]$TARGET$TARGET},
             error=function(cond) {return(NA)})
  if(is.null(geneid)) return(NA)
  if(is.na(geneid)) return(NA)
  ## parse the drugTargetID values - trim off extra characters and unnest where multiple targets per drug
  #trim everything up to "HSA:"
  geneid <- gsub(pattern = ".*\\HSA:", replacement = "", x=geneid) 
  # trim everything after square bracket
  geneid <- gsub(pattern = "\\].*", replacement = "", x=geneid) 
  # split on space into individual ids, where applicable
  geneid <- strsplit(geneid, split = " ")
  # unlist
  geneid <- unlist(geneid)
  # paste on a "hsa:"
  geneid <- paste0("hsa:",geneid)
  geneid <- as.list(geneid)
  return(geneid)
}



```



```{r map each drug ID to a target gene ID}
# drugs.targets$target_id <- NA

# drugs.targets$PreferredTerm[drugs.targets$drugID=="dr:D10231"]

temp_table <- data.frame(drugID= unique(na.omit(drugs.targets$drugID)), 
                         target_id = NA)


for(i in 1:nrow(temp_table)) {
  print(i)
  drugid <- as.character(temp_table$drugID[i])
  print(drugid)
  target_id <- getDrugTargetID(drugid)
  print(target_id)
  temp_table$target_id[i] <- list(target_id)
}


## unnest
temp_table <- as.data.frame(unnest(data = temp_table, target_id, keep_empty = FALSE))
temp_table$target_id <- as.character(temp_table$target_id)
## drop any null rows
temp_table <- temp_table[temp_table$target_id != "NULL", ]
```





```{r define function to get drug target symbols from KEGG via API}}
# keggGet("hsa:3620")[[1]]$SYMBOL[1]


getDrugTargetSymbol <- function(targetID){
  if(is.na(targetID)) return(NA)
  geneSymbol <- tryCatch({
    keggGet(targetID)[[1]]$SYMBOL[1]
    }, error=function(cond) {return(NA)})
  if(is.null(geneSymbol)) return(NA)
  if(is.na(geneSymbol)) return(NA)
  ## parse value
  ## multiple symbols separated by comma, we want the first one...
  geneSymbol <- gsub(pattern = ",.*", replacement = "", x=geneSymbol)
  
  return(geneSymbol)
}
```



```{r get drug symbols using function}
temp_table$target_symbol <- NA

tic("get drug target symbols")
for(i in 1:nrow(temp_table)) {
  print(i)
  targetID <- temp_table$target_id[i]
  print(targetID)
  temp_table$target_symbol[i] <- getDrugTargetSymbol(targetID)
  print(temp_table$target_symbol[i])
}
toc()


# temp_table[temp_table$target_symbol != "NA", ]
temp_table <- temp_table[complete.cases(temp_table), ]


# 
# ## reorder columns
# drugs.targets <- unique(dplyr::select(drugs.targets,"interventions.verbatim"= "interventions", interventions.processed, Description, ParentTerm, drugTargetSymbol))
```
  


```{r join target name to interventions}
drugs.targets <- unique(merge(x=drugs.targets, by.x="drugID", all.x=TRUE, y=temp_table, by.y = "drugID"))



```

```{r join mechanisms from NCIt}
drugs.targets <- unique(merge(x=drugs.targets, by.x="NCI_ID", all.x=TRUE, y=unique(dplyr::select(NCIthesaurus, ID, Class, ParentTerm)), by.y = "ID"))



## write to database

```

```{r join drugs targets back to nct_id}

cancerStudiesResults_interventions <- unique(merge(x=unique(dplyr::select(cancerStudiesResults, nct_id, interventions)), by.x = "interventions", y=drugs.targets, by.y="interventions"))



cancerStudiesResults
```


```{r write tables to database}
## write tables to database
dbWriteTable(conn = con,name = "drugs.targets", value = drugs.targets, overwrite=TRUE)




dbWriteTable(conn = con,name = "cancerStudiesResults_interventions", value = cancerStudiesResults_interventions, overwrite=TRUE)



dbListTables(con)


```


   
   